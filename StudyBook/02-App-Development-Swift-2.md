
Swift でのアプリ開発 2
今回の環境は、

macOS Big Sur 11.4
Xcode 12.5.1 (12E507)
です。

目次
アルゴリズムと API
定数と変数
型
意思決定を行う
アルゴリズムと API
これまで Swift でコードを書いてきましたが、その際に様々な関数を利用してきたことかと思います。
これらの関数は自分で定義したもの以外にも、Standard Library や Foundation Framework, その他のライブラリやフレームワークにて定義されたものがあります。

このようなプログラミングをするための関数や命令の集合のことを API (Application Programming Interface) といいます。
ある機能を使うのに、それが関数になっていると便利なことがいくつかあります。

再使用できるので読んだり入力する手間を省ける
使う場所で呼び出すだけなので、その機能を実現するための手順を考えなくてもよい
関数を変更するとそれを呼んでいるすべての場所で変更が適用される
実際の開発では、いくつもの API を組み合わせてアプリケーションを実装していきます。
そのように何かを達成する一連の手順を定義することを「アルゴリズムの開発」と呼びます。

アルゴリズムの定義はプログラミングの大部分を占めます。
インターネットで動画配信を効率的に行うために動画を圧縮するような複雑で数学的なアルゴリズムもありますし、アプリケーションのユーザが新着メッセージを確認した際にメッセージを表示するアルゴリズムのように数学に関係ないものもあります。

自己完結型の段階的な一連の操作であれば、どのようなものでもアルゴリズムです。

API の利用
Xcode Playground で API の利用方法を実際に手を動かしながら学んでいきましょう。
Foundation Framework から提供される Date 構造体を利用して、現在の日付を取得してみましょう。

Xcode を開き、新しい Playground を作成してください。
Playground を作成したら、以下のコードを記述して実行してください。

import Foundation

let currentDate = Date()
print(currentDate)

実行すると、現在の日付が出力されます。

現在の日付が出力される
import Foundation は Foundation モジュールをインポートすることを示しています。
import は他のモジュールを利用するために必要な宣言です。

import <#module#>

<#module#> はプレースホルダーです。実際のコードでは、インポートするモジュール名を記述します。

let currentDate = Date() は Date 構造体のインスタンスを生成して、currentDate 定数に代入しています。
Date 構造体は Foundation Framework に提供されている、日付を表す構造体です。

print(currentDate) は currentDate のテキスト表現をコンソールに出力しています。

このように、Date 構造体を使用すると、とても簡単に日付に関する処理を行うことができます。
他にも、Foundation モジュールの API を使用してみましょう。

今まで学習した内容に関する練習問題を解いてみてください。

練習問題
問1
次のうちアルゴリズムの説明として最も適当なものはどれでしょうか。

×
圧縮のこと
○
自己完結型の段階的な一連の操作
×
キーボードを叩く周期のこと
問2
応用（アプリケーション）ソフトウェアから利用可能なインタフェースのこと API は関数や命令の集合のことを指します。 この関数のメリットとして最も適当なものはどれでしょうか。

×
再使用できるので読んだり入力する手間を省ける
×
使う場所で呼び出すだけなので、その機能を実現するための手順を考えなくてもよい
×
関数を変更するとそれを呼んでいるすべての場所で変更が適用される
○
全て
解説
答えを隠す

問1
自己完結型の段階的な一連の操作であればどのようなものでもアルゴリズムです。
圧縮技術にはアルゴリズムが用いられている場合がほとんどですが圧縮はアルゴリズムではありません。

問2
列挙されている事項はすべて関数のメリットとして正しいです。

まとめ
iOS アプリ開発をする上で様々な API を利用することになります。
API は便利ですが、馴染みのない機能を利用することになるのでドキュメントをよく読んで利用しましょう。

定数と変数
Swift のプログラミングでは値を直接扱うことはありません。
定数や変数に値を格納して、その定数や変数に対する操作を行うことで値を扱います。

定数と変数はそれぞれ性質が異なります。

定数の値は変わりません。
例えば、誕生日は定数です。
何歳になっても変わることはありません。

一方、変数の値は変わり得ます。
例えば、住んでいる場所は変数です。
引っ越しなどで変わることがあります。

このように値がどのような意味を持つかで定数と変数を選択していきましょう。

定数
定数は let キーワードを用いて宣言されます。
定数に一度値を割り当てると、その後に値を変更することはできません。

let birthday = "2006/12/12" // 誕生日は変わらないため、定数を使用する
birthday = "2007/12/12" // エラーになり、再代入できない

定数は初期値を省略することはできません。

let birthday: String // 初期値がないため、エラーになる

変数
変数は var キーワードで宣言されます。
変数は値を変更できます。

var address = "東京都 " // 住所は変わる可能性があるため、変数を使用する
address = "神奈川県" // 再代入できる

変数は初期値を省略することができます。

var address: String // 初期値がなくてもエラーにならない

構文
定数と変数は以下のように初期化します。
初期化とは、定数や変数の宣言と同時に値を代入することです。

let myConstant: String = "定数"
var myVariable: String = "変数"

let や var に続けて定数名や変数名を記述します。
定数や変数の識別子は lowerCamelCase にします。

識別子に続けて型注釈を記述します。
型注釈は : String のように型を明示的に指定することです。

しかし、ほとんどの場合は型注釈は必要はありません。
後述しますが、これはコンパイラが型を推論してくれる型推論という機能があるためです。

そのため、以下のように記述することもできます。

let myConstant = "定数"
var myVariable = "変数"

ただし、変数の初期値がない場合は型注釈が必要です。

var myVariable: String

代入は = に続けて式を記述します。
この式の値が定数や変数に格納されます。

複数の定数や変数を , で区切って一度に宣言することもできます。

// 複数の Int 型の定数を初期化
let myConstant1 = 1, myConstant2 = 2, myConstant3 = 3

// 複数の String 型の変数を定義（型注釈のみ）
var myVariable1, myVariable2, myVariable3: String

機能だけをみれば、すべて変数を使用しても良いように思えます。
しかし、変数の値は変更できるため、プログラムの動作を予測しづらくなります。
また、とくに変数の値に依存するプログラムの処理が存在する場合に問題となりえます。
例えば、変数が意図せずに変更されてしまった場合に予期しない動作をするかもしれません。

それに対して、定数は一度初期化したら変更できないため、プログラム全体で一貫性が保たれます。
この一貫性によってプログラムのバグやリスクを減らすことができるのです。

そのため、変更の必要がない場合、つまり値が固定であるべき場合は定数を使用するべきです。
これによってプログラムの信頼性や保守性、可読性を高めることができます。

演習問題
5 年後の年齢
あなたの年齢を定数または変数として宣言して、5 年後の年齢に更新してください。

ある惑星で 10 年生活した年齢
ある惑星では、1 年が地球の約 1.9 年に相当するとされています。

あなたの年齢を定数または変数として初期化してください。

この惑星での 1 年を定数または変数として初期化してください。

また、この惑星で 10 年間生活した場合、あなたは地球の年齢言うと何歳になるのか計算してください。
その結果を定数または変数に代入して、さらにコンソールに出力してください。

宇宙旅行のプランニング
あなたは宇宙旅行会社で働いています。
あるお客さまが太陽系の別の惑星に旅行する計画を立てています。

お客さまの名前は「ドワンゴ太郎」です。
お客さまの名前を定数または変数に格納してください。

ドワンゴ太郎さんは行き先の惑星をまだ決めていません。
行き先の惑星を格納する定数または変数を宣言して、初期値として「未定」を設定してください。

ドワンゴ太郎さんが行き先を「火星」に決めました。
行き先の惑星を格納する定数または変数の値を更新してください。

ドワンゴ太郎さんの宇宙船の出発日は 2023/10/1 です。なお、出発日は変えることはできません。
出発日を格納する定数または変数を宣言してください。

お客さまの名前、行き先の惑星、出発日をコンソールに出力してください。

演習問題の解答例
答えを隠す

5 年後の年齢
// 年齢は変わるので変数を使用する
var myAge: Int = 16
myAge += 5

ある惑星で 10 年生活した年齢
let myAge = 16 // 惑星で生活し始めた時の年齢を定数として初期化する
let oneYearInPlanet = 1.9 // 地球と比べた場合のこの惑星での 1 年の長さの倍率を定数として初期化する
let yearsLivedInPlanet = 10 // この惑星で生活する年数を定数として初期化する

// この惑星で 10 年生活した年齢を計算してコンソールに出力する
let ageAfterLivingInPlanet = Double(myAge) + oneYearInPlanet * Double(yearsLivedInPlanet) 
print("この惑星で \(yearsLivedInPlanet) 年生活すると、私は地球で \(ageAfterLivingInPlanet) 歳になります。")

宇宙旅行のプランニング
// お客さまの名前は変わらないので定数を使用する
let customerName = "ドワンゴ太郎"

// 行き先の惑星は未定で変わる可能性もあるので変数を使用する
var destinationPlanet = "未定"

// 行き先の惑星が決まったので変数の値を更新する
destinationPlanet = "火星"

// 出発日は変えられないので定数を使用する
let departureDate = "2023/10/1"

// お客さまの名前、行き先の惑星、出発日をコンソールに出力する
print("\(customerName) さんは \(departureDate) に \(destinationPlanet) に向けて出発します！🚀")

今まで学習した内容に関する練習問題を解いてみてください。

練習問題
問1
変数と定数の説明として最も適当なものはどれでしょう。

×
変数は一度代入してしまうと二度と代入されている値を変更できないため、誕生日など後から変わらない値を格納するために使うと良い
×
定数は代入しても何度も値を変更できるため、今の得点など都度変更されるものを格納するために使うと良い
○
変数は代入しても何度も値を変更できるため、現在の気温など都度変更されるものを格納するために使うと良い
×
定数は一度代入してしまうと二度と代入されている値を変更できないため、できる限り使わない方が良い
問2
正しく変数を宣言しているのは次のうちどれでしょうか。

×
  letmyName = "Tom"

×
  let myName = "Tom"

○
  var myName = "Tom"

×
  var "myName" = Tom

問3
正しく定数を宣言しているのは次のうちどれでしょうか。

×
  const myName = "Tom"

○
  let myName = "Tom"

×
  let myName = "Tom

×
  let myName = Tom

問4
このコードを実行した後の count の値として適当なものはどれでしょうか。

let count = 1
count = 2

×
0
×
1
×
2
○
実行することができない（エラーが出力される）
問5
このコードを実行した後の count の値として適当なものはどれでしょうか。

var count = 1
count = 2

×
0
×
1
○
2
×
実行することができない（エラーが出力される）
問6
このコードを実行した後の count の値として適当なものはどれでしょうか。

var count = 1
count += 2
count++

×
2
×
3
×
4
○
実行することができない（エラーが出力される）
問7
このコードを実行した後の count の値として適当なものはどれでしょうか。

var count = 1
count = count + 2
count += 2
count -= 2

×
2
○
3
×
4
×
実行することができない（エラーが出力される）
問8
このコードを実行した後の str の値として適当なものはどれでしょうか。

var str = "1"
str += "2"
str += "3"

×
"321"
×
"6"
○
"123"
×
123
解説
答えを隠す

問1
定数の値は常に同じです。
変数の値は時間とともに変わり得ます。
変わらない値に変数を使うと参照した時によって値が変わっている可能性があり、バグの原因になるため、定数でよい場合は可能な限り定数を使用するようにしましょう。

問2
1は let と宣言する名前の間に半角スペースが入っていないため誤りです。
letmyName というひと続きの単語であると解釈されてしまいます。
let は定数を宣言します。それに対し var は変数を宣言します。

let 定数名 = 値
var 変数名 = 値

以上のように宣言をします。
そのため変数を宣言できるのは、3,4となります。
しかし4は宣言される名前にダブルクォーテーションが入っています。手元で実行してみるとわかりますが、定数名や変数名に " を含む名前をつけることはできません。

問3
1は Swift で const を用いることができないため正しくありません。
3は ダブルクォーテーションが一つしかなく、組になっていないため正しくありません。
4は Tom が " で囲まれていないため、文字列とは解釈されないことから 4 は定数を宣言できていません。

問4
let は定数を宣言します。定数は後から変更することができません。

問5
var は変数を宣言します。変数は後から変更することができるため、1で初期化され2行目の2によって上書きされ最終的には2となります。

問6
他のプログラミング言語では使えることの多いインクリメント演算子ですが Swift では Swift3 で削除されました。
+= 1 を利用しましょう。
同じくデクリメント演算子も使用することができません。それぞれ以下の様なエラーが表示されます。
Cannot find operator '++' in scope; did you mean '+= 1'?
Cannot find operator '--' in scope; did you mean '-= 1'?

問7
2行目は右辺を評価すると、 count + 2 の count が 1行目時点で 1 なので 3 になります。
これを count に代入するので、2行目終了時点では 3 となります。
また、count += 1 は count = count + 1 と同じです。

問8
文字列は + で連結できます。
"1" と "2" と "3" を連結させたものが答えなので、 3 です。
1 は逆に連結されています。
2 は整数として加算されています。
4 は文字列ではないです。

まとめ
参照するタイミングで値が異なることを、 プログラムが状態を持つ と呼びます。
変数はプログラムに状態を持たせるものです。

これでコードで表現できることが広がります。
しかし使う場所に気をつけないとエラーの原因になります。

定数と変数、それぞれどのような場面で使うべきかを理解することはとても大切です。
今後も定数と変数を使ったコードが出てきますが、不安な人はこのセクションをしっかり復習しておきましょう。

型
これまで String や Int といった型を使用してきました。
このセクションでは、Swift の型システムについて詳しく学びます。

型とは、値の種類を表すものです。
Swift は名前付き型と複合型の 2 種類の型があります。

名前付き型は Int や String のような、名前が付けられた型です。
クラス、構造体、列挙型、プロトコルが名前付き型に分類されます。
これらは開発者が定義した型や標準ライブラリで提供されている型です。

複合型は (name: String, age: Int) や (Int, Int) -> Int のような、複数の型を組み合わせて定義される名前のない型です。
タプル型、関数型が複合型に分類されます。

型安全
Swift の特徴の一つに強い静的型付けがあります。

例えば Int 型の変数に String 型の値を代入すると、以下のようなエラーになります。
これは String 型の値を Int 型に代入できない という意味です。

var age: Int = 16
age = "16" // --> Cannot assign value of type 'String' to type 'Int'

変数の値は変えることができますが、型は変えることができません。

これは非常に重要な機能です。
コンパイラが型の誤用を検出してくれるため、このような型の違いによるミスや混乱を防ぐことができます。

「静的型付け」と「動的型付け」
「静的型付け」と「動的型付け」について説明します。

静的型付け
「静的型付け」とは、コンパイル時など、プログラムの実行前に型が決まる仕組みです。
例えば Swift や Kotlin などは静的型付け言語です。

静的型付けのメリットとして、以下のようなことが挙げられます。

型の不一致や存在しないメソッドの呼び出しなど、多くの問題をコーディングの段階で発見できます。
型情報が実行前に確定するため、実行中の型チェックが不要になり、プログラムの実行速度が向上します。
どのようなデータを扱っているのか明確に示すため、コードの可読性を向上させたり、ドキュメントとしての機能も果たします。
動的型付け
「動的型付け」とは、プログラムの実行時に型が決まる仕組みです。
例えば JavaScript や Python などは動的型付け言語です。

動的型付けのメリットとして、以下のようなことが挙げられます。

型を動的に決定できるため、一般的に型を記述する必要はなく、コーディングが簡単かつ迅速になります。
型の制約が少ないため、さまざまな型のデータを簡単に組み合わせて機能の追加や変更をすることができます。
多くのインタプリタ型言語が動的型付けを採用しているため、学習コストが低く、初学者が習得しやすくなります。
「強い型付け」と「弱い型付け」
プログラミング言語には、型の取り扱いにおいて「強い型付け」や「弱い型付け」が存在します。
「強い型付け」や「弱い型付け」とは、型の一貫性を厳密に強制すること、それほど厳密に強制しないことです。

それぞれの特徴、その違いについて説明します。

強い型付け
強い型付け言語は型ルールが厳格であり、例えば異なるデータ型同士で演算をした場合はエラーになります。
これにより、型に関連する潜在的な問題を未然に防ぐことができます。

Swift は強い型付け言語です。
例えば、以下の Swift コードでは、コンパイルエラーが発生します。

var number: Int = 2525
number = "2525" // エラーになる

// 同じ型になるように明示的に型変換する必要がある
String(25) + "25" // "2525" という文字列になる
25 * Int("25")! // 625 という数値になる

弱い型付け
弱い型付け言語は型ルールが緩やかであり、例えば異なるデータ型同士で演算をした場合は暗黙的に型変換されます。
これにより、コードは柔軟でシンプルになりますが、予測が困難な挙動をする可能性もあります。

JavaScript は弱い型付け言語です。
例えば、以下の JavaScript コードでは、エラーが発生せずに実行できます。

let number = 2525;
number = '2525'; // エラーにならない

// 同じ型になるように暗黙的に型変換される
25 + '25'; // '2525' という文字列になる
25 * '25'; // 625 という数値になる

// 予測が困難な挙動をする
2525 + true; // 2526 という数値になる
2525 * 'ニコニコ'; // NaN という特殊な数値になる

型識別子
型識別子は型を示す一意の名前です。
例えば、整数型は Int という型識別子、文字列型は String という型識別子を使用します。

let name: String = "ドワンゴ太郎" // String 型
let grade: Int = 1 // Int 型

タプル型は (String, Int) のような型識別子、関数型は (Int, Int) -> Int のような型識別子になります。

(String, Int) は String 型の要素と Int 型の要素を 1 つずつ含むタプルを表す、タプル型の型識別子です。
(Int, Int) -> Int は Int 型の引数を 2 つ受け取り、Int 型の戻り値を返す関数を表す、関数型の型識別子です。
let student: (String, Int) = ("ドワンゴ太郎", 1) // (String, Int) 型（タプル型）
let add: (Int, Int) -> Int = { a, b in a + b } // (Int, Int) -> Int 型（関数型）

型注釈
型注釈は型を明示的に指定する方法です。
型注釈は : に続けて型識別子を記述します。

let student: (String, Int) = ("ドワンゴ太郎", 16) // (String, Int) 型に指定する
let name: String = "ドワンゴ太郎" // String 型に指定する
let age: Int = 16 // Int 型に指定する

型エイリアス
型エイリアスは型に別名を付ける機能です。
typealias キーワードを使用して、型エイリアスを定義することができます。

typealias Student = (name: String, grade: Int)
let student: Student = (name: "ドワンゴ太郎", grade: 1)

型推論
型推論は型注釈を省略した場合にコンパイラが型を推論する機能です。
例えば、定数や変数に初期値が代入されている場合、その値から型を推論することができます。

let student = ("ドワンゴ太郎", 16) // (String, Int) 型と推論される
let name = "ドワンゴ太郎" // String 型と推論される
let age = 16 // Int 型と推論される

演習問題
色の表現
コンピューターで色を扱う際に光の三原色(RGB)に透明度を加えた RGBA (Red, Green, Blue, Alpha) が使われることがあります。
RGBA は赤、緑、青の 3 色を 0 から 255 の範囲で表現して、透明度を 0 から 1 の範囲で表現します。
透明度は 1.0 で完全に不透明、0.0 で完全に透明を意味します。

例えば緑色は RGBA で以下のように表現できます。


 RGBA(38, 221, 86, 1.0)
RGBA をタプル型で表現してください。
また、好きな色をタプルで表現して、color という定数に代入してください。

型エイリアス
型エイリアスを使用して、RGBA を表すタプル型の型識別子を扱いやすくしてください。
この型名は RGBA としてください。

演習問題の解答例
答えを隠す

色の表現
名前無しタプル
let color: (Int, Int, Int, Double) = (38, 221, 86, 1.0)

名前付きタプル
let color: (red: Int, green: Int, blue: Int, alpha: Double) = (red: 38, green: 221, blue: 86, alpha: 1.0)
// または let color: (red: Int, green: Int, blue: Int, alpha: Double) = (38, 221, 86, 1.0)

型エイリアス
名前無しタプル
typealias RGBA = (Int, Int, Int, Double)
let color: RGBA = (38, 221, 86, 1.0)

名前付きタプル
typealias RGBA = (red: Int, green: Int, blue: Int, alpha: Double)
let color: RGBA = (red: 38, green: 221, blue: 86, alpha: 1.0)
// または let color: RGBA = (38, 221, 86, 1.0)

今まで学習した内容に関する練習問題を解いてみてください。

練習問題
問1
var a = "ZEN Study"

a の型はとして最も適当なものはどれでしょうか。

×
Int
○
String
×
日本語
×
ZEN Study
問2
Age の型はとして最も適当なものはどれでしょうか。

var age = 12

×
Double
×
age
×
Float
○
Int
問3
var temperature: Double = 39

temperature の型はとして最も適当なものはどれでしょうか。

×
String
×
Int
○
Double
×
Temperature
問4
var foo: SolarPhenomenon

以上で定義される変数 foo の型は、次のうちのどれでしょうか。

○
SolarPhenomenon
×
Interstellar
×
変数
×
未定義
問5
明示的に型を書かなくても型が決定する Swift の機能はどれでしょうか。

○
型推論
×
型安全
×
型決定
×
型明示
問6
let seconds: Double = 23

このコードにおいて Swift は次のうちどれによって seconds の型を判断するでしょうか。

×
型推論
×
型決定
○
型アノテーション
×
型スイローン
問7
型アノテーションを正しく行えているのは次のうちどれでしょうか。

×
Double count = 100

×
let count = 100

○
let count: Double = 100

×
let (count = 100): Double

問8
Xcode において変数や定数の型がわからない場合はどのようにして型を調べるのが最も適当でしょうか。

×
変数の色によって判断する
○
Xcode で Option キーを押しながら定数や変数をクリックする
×
コードを最初から全部見て候補を探す
×
候補の型を持つ値を代入しエラーの発生の有無で型を判断する
問9
宣言された変数や定数の型を変更する方法として最も適当なものはどれでしょうか。

×
定数の型は変更できないが変数は新しい型を持つ値を代入することによって変更できる
×
再び var, let を用いて型アノテーションで型を明示することで変更できる
○
型の変更はできない
×
free を用いて型を解放し再度宣言する
解説
答えを隠す

問1
"ZEN Study" は文字列リテラルです。

問2
12 は整数リテラルです。

問3
型アノテーションがあると右辺のリテラルに関係なく明示された型になります。

問4
このように型を明示的に記述することを 型アノテーション (Type Annotation) といいます。

問5
今までは明示的に型を書かなくても型が決定されていました。
それは Swift の 型推論 (Type Inference) の機能によるものです。
型推論は右辺の型を判定して左辺の型を決定します。

問6
型が明示されている、型アノテーションを優先させます。

問7
let 定数名: 型名 です。変数の場合は let が var になります。

問8
型が判別できない時は、エディタの機能を使って確認するのが便利です。

問9
型は変更できません。その場合は新しい値を宣言する必要があります。

まとめ
型を扱うことは強い静的型付けである Swift を使う上でとても大切です。
ある値の型は変わることがないので、値が何である可能性があるか、その値が何をするか、 どのように値が振る舞うかを特定することが容易になります。

意思決定を行う
プログラムは多くの場面で「もし～だったら～する」といった判断が必要になります。
このセクションでは、Swift における意思決定の基本、すなわち条件分岐に焦点を当てて解説します。

真偽値
Swift における真偽値は Bool 型で表現されます。
Bool は true (真) または false (偽) の値をとります。

これは条件分岐の判断の基盤となります。

比較演算子
条件を判定するための基本的な演算子に比較演算子があります。
Swift では、以下の比較演算子を使用できます。

これらの比較演算子は式が真か偽か判定して、真偽値を返します。

演算子	説明
A < B 	A は B より小さい（未満）
A > B 	A は B より大きい（超過）
A <= B	A は B 以下
A >= B	A は B 以上
A == B	A と B は等しい
A != B	A と B は等しくない
小なり演算子 (<)
< は左辺の値が右辺の値より小さい場合に true, それ以外の場合に false を返します。

// 1 は 2 より小さい（未満）
1 < 2 // --> true

大なり演算子 (>)
> は左辺の値が右辺の値より大きい場合に true, それ以外の場合に false を返します。

// 2 は 1 より大きい（超過）
2 > 1 // --> true

小なりイコール演算子 (<=)
<= は左辺の値が右辺の値より小さいか等しい場合に true, それ以外の場合に false を返します。

// 1 は 2 以下
1 <= 2 // --> true

大なりイコール演算子 (>=)
>= は左辺の値が右辺の値より大きいか等しい場合に true, それ以外の場合に false を返します。

// 2 は 1 以上
2 >= 1 // --> true

等価演算子 (==)
== は左辺の値が右辺の値と等しい場合に true, それ以外の場合に false を返します。

// 1 は 1 と等しい
1 == 1 // --> true

不等価演算子 (!=)
!= は左辺の値が右辺の値と等しくない場合に true, それ以外の場合に false を返します。

// 1 は 2 と等しくない
1 != 2 // --> true

論理演算子
複数の条件を組み合わせたり、真と偽を反転する際は論理演算子を使用します。
Swift では、以下の論理演算子を使用できます。

演算子	説明
A && B	A と B が真であれば真
A || B	A か B のどちらか、もしくは両方が真であれば真
!A	A が偽であれば真
論理積演算子 (&&)
&& は左辺の値と右辺の値が真の場合に true, それ以外の場合に false を返します。
左辺の値が偽の場合、右辺の値は評価されません。
これを短絡評価と呼びます。

let isSunny = true // 晴れているか？
let isWarm = true // 暖かいか？

// true && true
isSunny && isWarm // --> true

論理和演算子 (||)
|| は左辺の値か右辺の値が真の場合に true, それ以外の場合に false を返します。
左辺の値が真の場合、右辺の値は評価されません。

let isSunny = true // 晴れているか？
let isWarm = false // 暖かいか？

// true || false
isSunny || isWarm // --> true

論理否定演算子 (!)
! は真偽値を反転させます。
true は false, false は true に変換されます。

var isModalOpen = false // モーダルが開いているか？

// !false
!isModalOpen // --> true

if 文
Swift で条件分岐を行う最も基本的な方法は if 文を使用することです。
if 文は指定した条件が真の場合、その条件に対応するコードを実行します。

if に続けて条件式を記述します。
この条件式が真の場合 {} の中のコードが実行されます。

let age = 16

if age < 18 {
  print("あなたは未成年です。")
}

以上の例では age の値が 18 より小さい場合、"あなたは未成年です。" というメッセージが表示されます。

else 節
else 節を追加することで、条件が偽の場合に実行するコードを指定できます。

if age < 18 {
  print("あなたは未成年です。")
} else {
  print("あなたは成人です。")
}

以上の例では age の値が 18 より小さい場合は "あなたは未成年です。" というメッセージが表示されます。
それ以外の場合は "あなたは成人です。" というメッセージが表示されます。

else if 節
複数の条件を順番に判定する場合は else if 節を使用します。

let weather = "晴れ"

if weather == "晴れ" {
  print("今日は晴れています ☀")
} else if weather == "曇り" {
  print("今日は曇っています ☁")
} else if weather == "雨" {
  print("今日は雨が降っています 🌧")
} else {
  print("今日はどんな天気でしょうか？")
}

以上の例では weather の値が "晴れ", "曇り", "雨" の場合は天気に対応するメッセージを表示します。
それ以外の場合は "今日はどんな天気でしょうか？" というメッセージを表示します。

演習問題
Fizz Buzz ゲーム
Fizz Buzz は次のルールで数を数え上げる言葉遊びです。

1 から順に数を数え上げます。
その数が 3 の倍数の場合 "Fizz" を発言します。
その数が 5 の倍数の場合 "Buzz" を発言します。
その数が 3 と 5 の公倍数、つまり 15 の倍数の場合 "Fizz Buzz" を発言します。
それ以外の場合、その数を発言します。
たとえば、15 までの数は次のようになります。

1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
Fizz Buzz
この Fizz Buzz を Swift で実装してみましょう。
1 から 100 までの Fizz Buzz をコンソールに出力するコードを書いてください。

以下の for-in ループを使用してください。
number に 1 から 100 までの数が順番に代入されます。

for number in 1...100 {
  // ...
}

ヒント
例えば 3 の倍数の判定は number % 3 == 0 で行えます。

% は剰余演算子です。
剰余演算子は左辺の値を右辺の値で割った余りを返します。

つまり number % 3 == 0 は number を 3 で割った余りが 0 か判定しています。
0 の場合は number は 3 の倍数であるということになります。

演習問題の解答例
答えを隠す

Fizz Buzz ゲーム
for number in 1...100 {
  if number % 15 == 0 {
    print("Fizz Buzz")
  } else if number % 5 == 0 {
    print("Buzz")
  } else if number % 3 == 0 {
    print("Fizz")
  } else {
    print(number)
  }
}

この Fizz Buzz の実装では、判定の順番が非常に重要です。
number % 15 == 0 の判定を最初に行う理由は 15 の倍数は 3 と 5 の両方で割り切れる数であるためです。
もし、この判定を他の条件の後に行うと、例えば number % 3 == 0 の条件に当てはまるため、15 の倍数でも "Fizz" と出力されてしまいます。
そのため、15 の倍数の判定を最初に行い、3 の倍数や 5 の倍数の判定を後に行う必要があるのです。

今まで学習した内容に関する練習問題を解いてみてください。

練習問題
問1
次のコードは正しく実行することができません。正しい対処法はどれでしょうか。

var count = 100
if(count > 50) {
  print("over")
  print("finish")
} elif (count == 50) {
  print("equal")
  print("finish")
} else {
  print("under")
  print("finish")
}

○
elif は Swift で使うことはできないため else if に変更する
×
{}で囲むのではなくコロンとインデントで if 文を記述する
×
if 文の条件式を () で囲んではいけないため外す
×
if 文の実行される部分は複数行に渡ってはいけないため削除する
問2
c が出力されるときに count に代入されている整数として正しいものはどれでしょうか。

var count = ***
if count > 50 {
  print("a")
} else if count < 43 {
  print("b")
} else {
  print("c")
}

×
0
×
60
○
43
×
-14
問3
yes と出力されるときに num に代入されている整数として正しいものはどれでしょうか。

var num = ***
if num % 2 == 0 {
  if num >= 0 {
    print("yes")
  }
}

○
4
×
-4
×
3
×
-3
解説
答えを隠す

問1
2,4は完全に誤りです。
3については、条件式を括弧で挟まなくても問題はないです。
また、括弧で挟んでいけないという規則はありません。

問2
結果として c が出力されるわけですから、count > 50 と　count < 43 が共に false となっている必要があります。
つまり count <= 50 かつ　count >= 43 である場合に条件を満たします。
よって選択肢のうち　43 のみが答えとなります。

問3
if 文は入れ子にすることができます。このコードの場合は num を2で割り切れるときに次の if 文が実行され、さらに num が0より大きい時に実行されます。
% は剰余演算子と呼ばれ、a%b の場合 a を b で割ったあまりを返します。
この時返された数が 0 に等しいかを判断することで a が b で割り切れるかを判断することができます。

まとめ
if 文はプログラミングを行う上で必須と言ってよいほど使用します。
どのように条件式を書けば想定した結果が得られるのか考えましょう。

また実際の開発では条件分岐のある関数はユニットテストで正確性を担保します。
ユニットテストについては 1章第7節 で触れていますので気になった方は見直してみてください。

今回はここまでです。

正解できなかった問題は Playground で試したりして復習をしておきましょう。

お疲れさまでした！
学習したことをSNSで報告しよう！


---
## リンク

[Swift Standard Library](https://developer.apple.com/documentation/swift/swift-standard-library)

[Foundation](https://developer.apple.com/documentation/foundation)

[Date](https://developer.apple.com/documentation/foundation/date)

[Int](https://developer.apple.com/documentation/swift/int)

[String](https://developer.apple.com/documentation/swift/string)

[TupleType](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/types/#Tuple-Type)

[Function Type](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/types/#Function-Type)

[Bool](https://developer.apple.com/documentation/swift/bool)
